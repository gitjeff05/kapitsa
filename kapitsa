#!/bin/bash

# Define a few colors for output
# https://misc.flogisoft.com/bash/tip_colors_and_formatting#terminals_compatibility
CL_DEF="\033[39m\033[49m"
CL_RED="\033[31m"
CL_CYA="\033[36m\033[49m"
CL_YEL="\033[33m\033[49m"

# Print .kapitsa config example
print_config_info() {
  echo -e "Kapitsa uses a json configuration file to know where to search for .ipynb files.\nThe value of \"path\" in the ${CL_CYA}.kapitsa${CL_DEF} config file must point to a valid path."
  echo "Multiple paths are allowed but must be separated by a colon (:)"
  echo -e "Only absolute paths or paths using the ${CL_CYA}\$HOME${CL_DEF} environment variable are valid.\n"
  echo -e "For example \"${CL_CYA}\$HOME/path/to/dir:/Users/everyone/notebooks${CL_DEF}\" is valid"
  echo -e "while \"${CL_CYA}\$NOTEBOOKS/dir:/Users/everyone/notebooks${CL_DEF}\" is not because \$NOTEBOOKS is not allowed.\n"
  echo "{\"path\":\"\$HOME/projects:\$HOME/github\"}" | jq .
}

# Check if the KAPITSA env var has been set
check_kapitsa_env_variable() {
  if [ -z "$KAPITSA" ]; then
    echo -e "${CL_RED}Error:${CL_DEF} 'KAPITSA' env variable not set. Set ${CL_CYA}KAPITSA${CL_DEF} to the path of your ${CL_CYA}.kapitsa${CL_DEF} config file."
    printf 'Either run the following or manually add it to %s/.bash_profile (or similar)\n\n' "$HOME"
    echo -e "${CL_CYA}export${CL_DEF} KAPITSA=\"\$HOME/.kapitsa\"\n"
    print_config_info
    return 1
  else
    return 0
  fi
}

# Ensure kapitsa environment variable is set and
# and config file contains valid path
check_kapitsa_config() {
  # Make sure $KAPITSA is pointing to a file.
  if [ ! -f "$KAPITSA" ]; then
    echo -e "${CL_RED}Error${CL_DEF}: Could not find ${CL_CYA}.kapitsa${CL_DEF} configuration file at ${CL_CYA}$KAPITSA${CL_DEF}.\n"
    print_config_info
    return 1
  fi
  # Make sure the json file has a path key and that it is a string
  if [ ! "$(jq '. | select(.path|type=="string")' <"$KAPITSA")" ]; then
    echo -e "${CL_RED}Error${CL_DEF}: Invalid or missing required key \"path\" in json file.\n"
    print_config_info
    return 1
  fi
}

# Print help info
kapitsa_help() {
  echo -e "kapitsa help:\n"
  echo -e "${CL_CYA}kapitsa ${CL_RED}list [path]${CL_DEF}              List all paths containing .ipynb files.
                                 Unless given optional path, search all paths in configuration file."
  echo -e "${CL_CYA}kapitsa ${CL_RED}search regex [-p path]${CL_DEF}   Output all cells matching on regex.
                                 Unless given optional path, search all paths in configuration file."
  echo -e "${CL_CYA}kapitsa ${CL_RED}recent${CL_DEF}                   List recently modified notebooks."
  echo -e "\nExamples\n"
  echo -e "${CL_CYA}kapitsa ${CL_RED}list .${CL_DEF}                   Lists all paths in current directory containing .ipynb files"
  echo -e "${CL_CYA}kapitsa ${CL_RED}search \"join\" ${CL_DEF}           Print code cells matching \"join\""
  echo -e "${CL_CYA}kapitsa ${CL_RED}search \"(join|concat)\" ${CL_DEF}  Print code cells matching on \"join\" or \"concat\"\n"
}

check_settings() {
  local path_list

  check_kapitsa_env_variable && check_kapitsa_config

  # Get a list of paths on separate lines
  path_list=$(jq '.path' <"$KAPITSA" | tr -d '[][:space:]"' | tr ':' '\n')
  # If path contains $HOME, ensure that it is defined
  if [[ $path_list =~ "\$HOME" ]]; then
    if [ -z "${HOME}" ]; then
      printf "You specified \$HOME in your \"path\" but your \$HOME environment variable is not set.\n\n"
      printf "\"path\": \"%s\"\n\n" "$(jq '.path' <"$KAPITSA" | tr -d '[][:space:]"')"
      print_config_info
      return 1
    fi
  fi

}

get_kapitsa_paths() {
  # Get a list of paths on separate lines
  path_list=$(jq '.path' <"$KAPITSA" | tr -d '[][:space:]"' | tr ':' '\n')

  # replace string $HOME with expanded shell variable $HOME
  paths="${path_list//\$HOME/$HOME}"
  echo "$paths"
}

kapitsa_search() {

  local search_string
  local path_list
  local paths

  # (todo jeff) zsh & bash arguments ordering
  # search string that was passed in
  search_string="$1"

  # Get a list of paths on separate lines
  path_list=$(jq '.path' <"$KAPITSA" | tr -d '[][:space:]"' | tr ':' '\n')

  # replace string $HOME with expanded shell variable $HOME
  paths="${path_list//\$HOME/$HOME}"

  # Run the search on each directory specified
  while IFS= read -r directory; do

    # break out if directory is not valid
    if [ ! -d "$directory" ]; then
      echo -e "${CL_YEL}Warning${CL_DEF}: $directory not a valid directory. Make sure your ${CL_CYA}.kapitsa${CL_DEF} config file contains a valid directory."
      break
    fi

    find_in_notebook_source "${directory}" "${search_string}"

    # TODO(jeff): Make searching for tags option

  done < <(echo "$paths")

}

#######################################
# kapitsa is the entry point
# Arguments:
#   [help|list|recent|search]
#######################################
kapitsa() {
  # The command passed to kapitsa [list|search|help]
  local option

  # check settings to make sure env variable is set
  # and config file is set
  check_settings

  # set option to 1st argument
  option="$1"

  # if [help|h|-h|-help] print help info
  if [[ "$option" == "help" ]] || [[ "$option" == "h" ]] || [[ "$option" == "-h" ]] || [[ "$option" == "-help" ]]; then

    kapitsa_help

  # list notebooks
  elif [[ "$option" == "list" ]] || [[ "$option" == "l" ]]; then

    local kapitsa_paths
    local all_dirs
    local all
    local nbs
    kapitsa_paths=$(get_kapitsa_paths)

    if [[ -z "$2" ]]; then
      # Run the search on each directory specified
      echo -e "Searching default paths: \n${kapitsa_paths}\n"
      all_dirs=()
      while IFS= read -r directory; do
        nbs=$(find_notebook_directories "${directory}" 1)
        while IFS=$'\n' read -r line; do all_dirs+=("$line"); done <<<"$nbs"
      done <<<"$kapitsa_paths"

      all=$(
        IFS=$'\n'
        echo "${all_dirs[*]}"
      )
      all_directories=()
      while IFS=$'\n' read -r line; do all_directories+=("$line"); done < <(echo "$all" |
        grep -o "\(.*\)/" |
        sort -u)
      echo "$(
        IFS=$'\n'
        echo "${all_directories[*]}"
      )"
      echo -e "\nFound ${#all_directories[@]} directories containing notebooks."
    else
      # call ./lib/find_notebook_directories to get a list of directories
      # containing .ipynb files
      local notebooks
      local array
      local count
      echo -e "Searching path ${2}\n"
      notebooks=$(find_notebook_directories "$2")

      # build an array from the results
      array=()
      while IFS=$'\n' read -r line; do array+=("$line"); done <<<"$notebooks"

      # count members of array
      count="${#array[@]}"

      # This is for bash/zsh interop.
      # For some reason 0th element is always unset in both bash/zsh
      # 1st element is set if array has > 0 members
      # However, passing current path "." results in the 0th member being set
      # (todo jeff): more testing around this
      if [[ -z "${array[1]}" ]] && [[ -z "${array[0]}" ]]; then
        echo "set count to 0"
        count=0
      fi

      echo "$notebooks"
      echo -e "\nFound ${count} directories containing notebooks."
    fi

  elif [[ "$option" == "recent" ]] || [[ "$option" == "r" ]]; then

    local kapitsa_paths
    local all_files
    local all

    kapitsa_paths=$(get_kapitsa_paths)

    # Run the search on each directory specified
    all_files=()
    while IFS= read -r directory; do
      local nbs
      nbs=$(find_recent_notebooks "${directory}" 1)
      while IFS=$'\n' read -r line; do all_files+=("$line"); done <<<"$nbs"
    done <<<"$kapitsa_paths"

    # sort and format list
    all=$(
      IFS=$'\n'
      echo "${all_files[*]}"
    )
    echo "$all" |
      sort -k1,19 -r |
      cut -c 21-

  elif [[ "$option" == "search" ]] || [[ "$option" == "s" ]]; then

    local args
    local search_arguments

    args=("$@")
    search_arguments=("${args[@]:1}")

    if [[ "${#search_arguments[@]}" -eq 1 ]]; then

      # Only the search regex was passed. Do default search across config paths
      kapitsa_search "${2}"

    elif [[ "${#search_arguments[@]}" -eq 3 ]]; then

      # Three arguments supplied. User is trying to supply a path to search

      # Check to make sure 2nd arg was the '-p' flag
      if [[ "${3}" != "-p" ]]; then
        echo -e "Incorrect argument order. Optional third argument must be -p followed by a valid path.\n"
        kapitsa_help
        return 1
      fi

      # Pass arguments to find_in_notebook_source
      find_in_notebook_source "${4}" "${2}"

    else

      echo -e "Incorrect number of arguments\n"
      kapitsa_help
      return 1

    fi

  else
    echo -e "Incorrect arguments\n"
    kapitsa_help
    return 1
  fi

}

# Main is run when we source ./kapitsa.
# It then sources the other functions in lib
main() {
  # check settings to make sure env variable is set
  # and config file is set
  check_settings

  # create array of libraries to source
  local libraries
  libraries=('find_notebook_directories' 'find_in_notebook_source' 'find_recent_notebooks')

  # source libraries
  for i in "${libraries[@]}"; do
    if [[ -r "./lib/$i.sh" ]] && [[ -f "./lib/$i.sh" ]]; then
      # shellcheck source=lib/find_notebooks.sh
      # shellcheck disable=SC1091
      . "./lib/$i.sh"
    fi
  done
}

main "$@"
